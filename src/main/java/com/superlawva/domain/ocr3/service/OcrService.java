package com.superlawva.domain.ocr3.service;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.api.gax.core.FixedCredentialsProvider;
import com.google.auth.oauth2.GoogleCredentials;
import com.google.cloud.documentai.v1.*;
import com.google.protobuf.ByteString;
import com.superlawva.domain.ocr3.dto.GeminiResponse;
import com.superlawva.domain.ocr3.dto.OcrResponse;
import com.superlawva.domain.ocr3.entity.ContractData;
import com.superlawva.domain.ocr3.repository.ContractDataRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.multipart.MultipartFile;

import java.io.FileInputStream;
import java.io.IOException;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Slf4j
@Service
@RequiredArgsConstructor
public class OcrService {
    
    private final ContractDataRepository contractDataRepository;
    private final RestTemplate restTemplate;
    private final ObjectMapper objectMapper;
    private final GoogleCredentials googleCredentials;
    
    @Value("${gcp.project-id}")
    private String projectId;
    
    @Value("${gcp.location}")
    private String location;
    
    @Value("${gcp.processor-id}")
    private String processorId;
    
    @Value("${gemini.api-key}")
    private String geminiApiKey;
    
    @Value("${gemini.model-name}")
    private String geminiModelName;
    
    @Value("${gemini.api-url}")
    private String geminiApiUrl;
    
    public OcrResponse processContract(MultipartFile file) throws Exception {
        log.info("Starting OCR processing for file: {}", file.getOriginalFilename());
        
        // üîç MongoDB Ïó∞Í≤∞ Ï†ïÎ≥¥ ÎîîÎ≤ÑÍπÖ
        log.info("üìä MongoDB Debug - Database: {}", contractDataRepository.getClass().getSimpleName());
        
        // Step 1: Extract text using Document AI
        String extractedText = extractTextFromImage(file);
        log.info("Text extraction completed");
        
        // Step 2: Analyze text with Gemini
        long startTime = System.currentTimeMillis();
        GeminiResponse geminiResponse = analyzeTextWithGemini(extractedText);
        double generationTime = (System.currentTimeMillis() - startTime) / 1000.0;
        log.info("Gemini analysis completed in {} seconds", generationTime);
        
        // Step 3: Prepare contract data
        ContractData contractData = geminiResponse.getContractData();
        contractData.setUserId(null); // Will be set based on authenticated user
        contractData.setGenerated(false);
        contractData.setFileUrl("file://" + file.getOriginalFilename());
        contractData.setCreatedDate(LocalDateTime.now(ZoneOffset.UTC));
        contractData.setModifiedDate(LocalDateTime.now(ZoneOffset.UTC));
        
        // Set metadata
        ContractData.ContractMetadata metadata = new ContractData.ContractMetadata();
        metadata.setModel(String.format("doc-ai:%s + gemini:%s", processorId, geminiModelName));
        metadata.setGenerationTime(generationTime);
        metadata.setUserAgent(null);
        metadata.setVersion("v3.1.0");
        contractData.setContractMetadata(metadata);
        
        // Step 4: Save to MongoDB with debug info
        log.info("üîç Saving contract to MongoDB...");
        ContractData savedContract = contractDataRepository.save(contractData);
        log.info("‚úÖ Contract saved with ID: {} | Database should be: superlawva_docs", savedContract.getId());
        
        // Step 5: Return response
        return OcrResponse.builder()
                .contractData(savedContract)
                .debugMode(geminiResponse.isDebugMode())
                .build();
    }
    
    // üü¢ ÏÇ¨Ïö©Ïûê IDÎ•º Ìè¨Ìï®Ìïú Í≥ÑÏïΩÏÑú Ï≤òÎ¶¨ Î©îÏÑúÎìú Ï∂îÍ∞Ä
    public OcrResponse processContractWithUserId(MultipartFile file, String userId) throws Exception {
        log.info("Starting OCR processing for file: {} with userId: {}", file.getOriginalFilename(), userId);
        
        // Step 1: Extract text using Document AI
        String extractedText = extractTextFromImage(file);
        log.info("Text extraction completed");
        
        // Step 2: Analyze text with Gemini
        long startTime = System.currentTimeMillis();
        GeminiResponse geminiResponse = analyzeTextWithGemini(extractedText);
        double generationTime = (System.currentTimeMillis() - startTime) / 1000.0;
        log.info("Gemini analysis completed in {} seconds", generationTime);
        
        // Step 3: Prepare contract data with userId
        ContractData contractData = geminiResponse.getContractData();
        contractData.setUserId(userId);  // üîó MySQL user.id ÏÑ§Ï†ï
        contractData.setGenerated(false);
        contractData.setFileUrl("file://" + file.getOriginalFilename());
        contractData.setCreatedDate(LocalDateTime.now(ZoneOffset.UTC));
        contractData.setModifiedDate(LocalDateTime.now(ZoneOffset.UTC));
        
        // Set metadata
        ContractData.ContractMetadata metadata = new ContractData.ContractMetadata();
        metadata.setModel(String.format("doc-ai:%s + gemini:%s", processorId, geminiModelName));
        metadata.setGenerationTime(generationTime);
        metadata.setUserAgent(null);
        metadata.setVersion("v3.1.0");
        contractData.setContractMetadata(metadata);
        
        // Step 4: Save to MongoDB with userId
        ContractData savedContract = contractDataRepository.save(contractData);
        log.info("Contract saved with ID: {} for userId: {}", savedContract.getId(), userId);
        
        // Step 5: Return response
        return OcrResponse.builder()
                .contractData(savedContract)
                .debugMode(geminiResponse.isDebugMode())
                .build();
    }
    
    private String extractTextFromImage(MultipartFile file) throws IOException {
        log.debug("Initializing Document AI client");
        
        DocumentProcessorServiceSettings settings = DocumentProcessorServiceSettings.newBuilder()
                .setEndpoint(String.format("%s-documentai.googleapis.com:443", location))
                .setCredentialsProvider(FixedCredentialsProvider.create(googleCredentials))
                .build();
        
        try (DocumentProcessorServiceClient client = DocumentProcessorServiceClient.create(settings)) {
            String name = String.format("projects/%s/locations/%s/processors/%s", 
                    projectId, location, processorId);
            
            ByteString content = ByteString.copyFrom(file.getBytes());
            
            RawDocument rawDocument = RawDocument.newBuilder()
                    .setContent(content)
                    .setMimeType(file.getContentType() != null ? file.getContentType() : "image/jpeg")
                    .build();
            
            ProcessRequest request = ProcessRequest.newBuilder()
                    .setName(name)
                    .setRawDocument(rawDocument)
                    .build();
            
            ProcessResponse result = client.processDocument(request);
            return result.getDocument().getText();
        }
    }
    
    private GeminiResponse analyzeTextWithGemini(String ocrText) throws Exception {
        log.debug("Preparing Gemini API request");
        
        String prompt = buildGeminiPrompt(ocrText);
        
        Map<String, Object> requestBody = new HashMap<>();
        
        // Build parts list
        List<Map<String, String>> partsList = new ArrayList<>();
        Map<String, String> part = new HashMap<>();
        part.put("text", prompt);
        partsList.add(part);
        
        // Build contents list
        List<Map<String, Object>> contentsList = new ArrayList<>();
        Map<String, Object> content = new HashMap<>();
        content.put("parts", partsList);
        contentsList.add(content);
        
        requestBody.put("contents", contentsList);
        
        Map<String, String> generationConfig = new HashMap<>();
        generationConfig.put("response_mime_type", "application/json");
        requestBody.put("generationConfig", generationConfig);
        
        String url = String.format("%s/v1beta/models/%s:generateContent?key=%s", 
                geminiApiUrl, geminiModelName, geminiApiKey);
        
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        
        HttpEntity<Map<String, Object>> entity = new HttpEntity<>(requestBody, headers);
        
        ResponseEntity<Map> response = restTemplate.postForEntity(url, entity, Map.class);
        
        if (response.getStatusCode() == HttpStatus.OK && response.getBody() != null) {
            Map<String, Object> responseBody = response.getBody();
            List<Map<String, Object>> candidates = (List<Map<String, Object>>) responseBody.get("candidates");
            Map<String, Object> candidate = candidates.get(0);
            Map<String, Object> candidateContent = (Map<String, Object>) candidate.get("content");
            List<Map<String, String>> parts = (List<Map<String, String>>) candidateContent.get("parts");
            String jsonText = parts.get(0).get("text");
            
            return objectMapper.readValue(jsonText, GeminiResponse.class);
        } else {
            throw new RuntimeException("Failed to get valid response from Gemini API");
        }
    }
    
    private String buildGeminiPrompt(String ocrText) {
        String schemaExample = getJsonSchemaExample();
        
        return String.format("""
        ÎãπÏã†ÏùÄ ÌïúÍµ≠ Î∂ÄÎèôÏÇ∞ Í≥ÑÏïΩÏÑúÎ•º Î∂ÑÏÑùÌïòÏó¨ JSONÏúºÎ°ú Î≥ÄÌôòÌïòÎäî AI Ï†ÑÎ¨∏Í∞ÄÏûÖÎãàÎã§.
        Îã§Ïùå OCR ÌÖçÏä§Ìä∏Î•º Î∂ÑÏÑùÌïòÏó¨, ÏïÑÎûòÏóê Î™ÖÏãúÎêú ÏÉÅÏÑ∏Ìïú JSON Íµ¨Ï°∞Ïóê ÎßûÏ∂∞ ÎÇ¥Ïö©ÏùÑ Ï±ÑÏõåÏ£ºÏÑ∏Ïöî.

        ### Îß§Ïö∞ Ï§ëÏöîÌïú Í∑úÏπô ###
        1.  **ÏóÜÎäî Ï†ïÎ≥¥Îäî Î∞òÎìúÏãú `null`**: ÌÖçÏä§Ìä∏Ïóê Î™ÖÏãúÏ†ÅÏúºÎ°ú Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Ï†ïÎ≥¥Îäî **Ï†àÎåÄÎ°ú** Ï∂îÏ∏°ÌïòÍ±∞ÎÇò ÎßåÎì§Ïñ¥ÎÇ¥ÏßÄ ÎßêÍ≥†, Î∞òÎìúÏãú `null` Í∞íÏúºÎ°ú Ï±ÑÏõåÏïº Ìï©ÎãàÎã§. Îπà Î¨∏ÏûêÏó¥("")Ïù¥ÎÇò Í∏∞Î≥∏Í∞íÏùÑ ÏÇ¨Ïö©ÌïòÏßÄ ÎßàÏÑ∏Ïöî.
        2.  **ÏôÑÏ†ÑÌïú Î¨∏Ïû•**: `articles`ÏôÄ `agreements` Ìï≠Î™©Ïóê Î¨∏ÏûêÏó¥ÏùÑ Ï∂îÍ∞ÄÌï† Îïå, Î¨∏Ïû•Ïù¥ Ï§ëÍ∞ÑÏóê ÎÅäÍ∏∞ÏßÄ ÏïäÎèÑÎ°ù ÏôÑÏÑ±Îêú Ï†ÑÏ≤¥ Î¨∏Ïû•ÏùÑ Ï∂îÏ∂úÌï¥Ïïº Ìï©ÎãàÎã§.
        3.  **Ï†ïÌôïÌïú Í∞í Ï∂îÏ∂ú**: ÌÖçÏä§Ìä∏Ïóê ÏûàÎäî ÎÇ¥Ïö©Îßå Ï†ïÌôïÌïòÍ≤å Ï∂îÏ∂úÌï©ÎãàÎã§.
        4.  **Ïà´Ïûê ÌòïÏãù**: Í∏àÏï°, Î©¥Ï†Å Îì±ÏùÄ Î∞òÎìúÏãú Îî∞Ïò¥Ìëú ÏóÜÎäî Ïà´Ïûê(Number) ÌòïÏãùÏúºÎ°ú Î≥ÄÌôòÌïòÏÑ∏Ïöî.
        5.  **ÏôÑÎ≤ΩÌïú JSON Ï∂úÎ†•**: ÏµúÏ¢Ö Í≤∞Í≥ºÎäî Ïò§ÏßÅ JSON Í∞ùÏ≤¥Îßå Î∞òÌôòÌï¥Ïïº Ìï©ÎãàÎã§. ÏÑ§Î™ÖÏù¥ÎÇò Îã§Î•∏ ÌÖçÏä§Ìä∏ ÏóÜÏù¥ ÏàúÏàòÌïú JSON ÌòïÏãùÏù¥Ïñ¥Ïïº Ìï©ÎãàÎã§.

        ### ÏµúÏ¢Ö Ï∂úÎ†• JSON Íµ¨Ï°∞ Î∞è ÏòàÏãú (Ïù¥ Íµ¨Ï°∞Î•º Î∞òÎìúÏãú Îî∞Î•¥ÏÑ∏Ïöî) ###
        %s

        ---
        ### Î∂ÑÏÑùÌï† Í≥ÑÏïΩÏÑú OCR ÌÖçÏä§Ìä∏ ###
        ```text
        %s
        ```
        ---

        Ïù¥Ï†ú, ÏúÑ Í∑úÏπôÍ≥º Íµ¨Ï°∞Ïóê Îî∞Îùº OCR ÌÖçÏä§Ìä∏Î•º Î∂ÑÏÑùÌïòÏó¨ ÏôÑÎ≤ΩÌïú JSONÏùÑ ÏÉùÏÑ±Ìï¥Ï£ºÏÑ∏Ïöî.
        """, schemaExample, ocrText);
    }
    
    private String getJsonSchemaExample() {
        return """
        {
          "contract_data": {
            "contract_type": "Ï†ÑÏÑ∏",
            "dates": { "contract_date": "2025-06-14", "start_date": "2025-07-01", "end_date": "2027-06-30" },
            "property": { "address": "ÏÑúÏö∏Ïãú ÏÑ±ÎèôÍµ¨ ÏÑ±ÏàòÎèô 101-12", "detail_address": "BÎèô 802Ìò∏ 8Ï∏µ", "rent_section": "Ï†ÑÏ≤¥", "rent_area": "70%", "land": { "land_type": "ÎåÄÏßÄ", "land_right_rate": "100Î∂ÑÏùò 35", "land_area": 150.2 }, "building": { "building_constructure": "Ï≤†Í∑ºÏΩòÌÅ¨Î¶¨Ìä∏", "building_type": "ÏïÑÌååÌä∏", "building_area": "99.23" } },
            "payment": { "deposit": 80000000, "deposit_kr": "ÌåîÏ≤úÎßåÏõêÏ†ï", "down_payment": 20000000, "down_payment_kr": "Ïù¥Ï≤úÎßåÏõêÏ†ï", "intermediate_payment": 30000000, "intermediate_payment_kr": "ÏÇºÏ≤úÎßåÏõêÏ†ï", "intermediate_payment_date": "2026ÎÖÑ3Ïõî15Ïùº", "remaining_balance": 30000000, "remaining_balance_kr": "ÏÇºÏ≤úÎßåÏõêÏ†ï", "remaining_balance_date": "2026ÎÖÑ6Ïõî30Ïùº", "monthly_rent": null, "monthly_rent_date": "5Ïùº", "payment_plan": null },
            "articles": [ "Ï†ú2Ï°∞ (Ï°¥ÏÜçÍ∏∞Í∞Ñ) ÏûÑÎåÄÏù∏ÏùÄ Í≥ÑÏïΩÍ∏∞Í∞Ñ ÎÇ¥ ÏûÑÏ∞®Ïù∏ÏóêÍ≤å Ìï¥Îãπ Ï£ºÌÉùÏùÑ ÏÇ¨Ïö©ÏºÄ ÌïúÎã§." ],
            "agreements": [ "ÏûÑÏ∞®Ïù∏ÏùÄ Î∞òÎ†§ÎèôÎ¨º ÏÇ¨Ïú° Ïãú ÏÜêÌï¥ Î∞úÏÉùÏóê ÎåÄÌïú Ï±ÖÏûÑÏùÑ ÏßÑÎã§." ],
            "lessor": { "name": "Ïù¥ÏòÅÌù¨", "id_number": "850212-2345678", "address": "ÏÑúÏö∏Ïãú ÏÑúÏ¥àÍµ¨", "detail_address": "Î∞òÌè¨Îèô 77-5", "phone_number": "02-555-6666", "mobile_number": "010-5555-6666", "agent": { "name": "Ïù¥ÏòÅÌù¨" } },
            "lessee": { "name": "ÍπÄÎØºÏ§Ä", "id_number": "920405-3456789", "address": "ÏÑúÏö∏Ïãú ÎÖ∏ÏõêÍµ¨", "detail_address": "Ï§ëÍ≥ÑÎèô 12-34", "phone_number": "02-777-8888", "mobile_number": "010-7777-8888", "agent": { "name": "ÍπÄÎØºÏ§Ä" } },
            "broker1": { "office": "ÏÑ±ÏàòÎ∂ÄÎèôÏÇ∞Ï§ëÍ∞úÎ≤ïÏù∏", "license_number": "123-45-67890", "address": "ÏÑúÏö∏Ïãú ÏÑ±ÎèôÍµ¨", "representative": "Î∞ïÎåÄÌëú", "fao_broker": "ÏµúÏ§ëÍ∞úÏÇ¨" },
            "broker2": { "office": null, "license_number": null, "address": null, "representative": null, "fao_broker": null }
          },
          "debug_mode": false
        }
        """;
    }
    
    // üü¢ MongoDB Ï†ÄÏû•Îêú Î™®Îì† Í≥ÑÏïΩÏÑú Ï°∞Ìöå
    public List<ContractData> getAllContracts() {
        log.info("Retrieving all contracts from MongoDB");
        return contractDataRepository.findAll();
    }
    
    // üü¢ ÌäπÏ†ï IDÎ°ú Í≥ÑÏïΩÏÑú Ï°∞Ìöå
    public ContractData getContractById(String id) {
        log.info("Retrieving contract with ID: {}", id);
        return contractDataRepository.findById(id).orElse(null);
    }
    
    // üü¢ ÏÇ¨Ïö©ÏûêÎ≥Ñ Í≥ÑÏïΩÏÑú Ï°∞Ìöå
    public List<ContractData> getContractsByUserId(String userId) {
        log.info("Retrieving contracts for user: {}", userId);
        return contractDataRepository.findByUserId(userId);
    }
}